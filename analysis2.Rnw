% -*- mode: noweb; noweb-default-code-mode: R-mode; -*-

\SweaveOpts{ results=hide}
\SweaveOpts{ include=FALSE}
\SweaveOpts{ echo=FALSE}
\SweaveOpts{ engine=R}
\SweaveOpts{ keep.source= TRUE}
\SweaveOpts{ eval=TRUE}

\graphicspath{ {analysis/} }

\chapter{Analysis}
\label{cha:analysis}

% , eval=TRUE>>=

<<init>>=

options( prompt= " ", continue= " ", width= 60)
options(error= function(){
  recover()
  options( prompt= "> ", continue= "+ ", width= 80)
})
  
source( "~/thesis/code/analysis.R")
source( "~/thesis/code/peel.R")

texWd <- "~/thesis/analysis"
rasterWd <- "~/thesis/data/analysis"
dataPath <- "~/thesis/data"
setwd( rasterWd)

overwriteRasters <- FALSE
overwriteFigures <- TRUE

                                        # studyArea used to work out RMSE
                                        # calcs and tables
##studyArea <- "thumb"
studyArea <- "mlct"
                                        # bands are numbered from one but
                                        # classes from zero.  Used for stacks/brick
                                        # where bands correspond to classes
peelBands <- peelClasses +1

                                        # mask and agland exported from GRASS
                                        # no need to mask or crop
cusaMask <- raster( "mask_cusa.tif")
cusaExtent <- extent( cusaMask)
thumbExtent <- extent( -( 83 +30 /60), -( 82 +25 /60),
                          42 +55 /60,     44  +5 /60 )

                                        # default raster() output
                                        # has geographic proj, full extent
                                        # by default
world <- raster()
res(world) <- 5/60

grid <- raster( cusaMask)
grid[] <- cellsFromExtent( world, grid)
grid <- mask( grid, cusaMask)

if( studyArea == "thumb") {
  cusaMask <- crop( cusaMask, thumbExtent)
}
acresFile <- paste( "acres",
                   paste( studyArea, ".tif", sep=""),
                   sep="_")
if( overwriteRasters) {
  acres <- area( cusaMask) *247.105381
  acres <- writeRaster( acres,
                       filename= acresFile,
                       overwrite= TRUE)
} else acres <- raster( acresFile)

agland <- stack( list.files( paste( dataPath, "agland", sep="/"),
                            patt= "(cropland|pasture).tif$",
                            full.names= TRUE))
layerNames(agland) <- c("crop", "open")
agland <- setMinMax( agland)
if( studyArea == "thumb") {
  agland <- crop( agland, thumbExtent)
}

agg05 <-
  brick( list.files( dataPath,
                    patt= paste( studyArea, "_Amin_0.5_agg.tif", sep=""),
                    full.names= TRUE))
layerNames( agg05) <- names( peelClasses)

nomos05 <-
  brick( list.files( dataPath,
                    patt= paste( studyArea, "_Amin_0.5_nomosaic.tif", sep=""),
                    full.names= TRUE))
layerNames( nomos05) <- c( names( peelClasses)[ -8], "total")

agg1 <-
  brick( list.files( dataPath,
                    patt= paste( studyArea, "1_agg.tif", sep=""),
                    full.names= TRUE)) 
layerNames( agg1) <- names( peelClasses)

nomos1 <-
  brick( list.files( dataPath,
                    patt= paste( studyArea, "1_Amin_1_nomosaic.tif", sep=""),
                    full.names= TRUE))
layerNames( nomos1) <- c( names( peelClasses)[ -8], "total")

## nlcd <- stack( paste( paste( dataPath, "nlcd", "nlcd", sep="/"), names( peelClasses[ -8]), "5min.tif", sep="_"))

nlcd <- stack( sapply( names( peelClasses[ -8]),
                      function( cover) {
                        list.files( paste( dataPath, "nlcd", sep="/"),
                                   patt= paste( "nlcd", cover, "5min.tif$", sep="_"),
                                   full.names= TRUE)
                      }))
nlcd <- setMinMax( nlcd)



nlcd <- crop( nlcd, cusaMask,
             ##filename= paste( getwd(), "nlcd.tif", sep="/"),
             filename= "nlcd.tif",
             overwrite= TRUE)
layerNames(nlcd) <- names( peelClasses[ -8])

rasterNames <- c( "agland", "nlcd", "agg05", "agg1", "nomos05", "nomos1")

dataSets <- sapply( rasterNames, function( n) eval( parse( text=n)))

areas <- llply( dataSets,
function( d) {
  res <- cellStats( d *acres, sum)
  names( res) <- layerNames( d)
  res
})

## llply( areas, function( a) melt( a, value.name= deparse( substitute( a))))

areasDf <-
  ldply( areas, function( a) {
    melt( t( as.data.frame( a)))
  })
areasDf <-
  areasDf[, c( 1, 3, 4)]
colnames( areasDf) <-
  c( "map", "class", "acres")
areasDf$map <-
  factor( areasDf$map,
         levels= rasterNames)

## causes things to be in the wrong order
## areasDf$class <-
##   factor( areasDf$class,
##          levels= c( names( peelClasses), "total"))

if( overwriteFigures) areasPlot <-
  qplot( map, acres /10^6,
        data= subset(areasDf, class != "total"),
        geom="bar", position= "stack",
        fill= class,
        stat="summary", fun.y="sum") +
  scale_fill_manual( "",
                    values= peelLegend, #peelLegend[ levels( areasDf$class)[1:9]],
                    breaks= names( peelClasses)) +
  scale_y_continuous( "Ma",
      limits= c(0,2000)) +
  theme_bw() +
  scale_x_discrete( "",
      limits= rasterNames[ c( 1, 2, 4, 3, 6, 5)],
      breaks= rasterNames[ c( 1, 2, 4, 3, 6, 5)],
      labels= expression("Agland2000", "NLCD",
          atop( atop( textstyle( "MLCT"),
                     textstyle( A[ min] ==1.0)),
               phantom(0)),
          atop( atop( textstyle( "MLCT"),
                     textstyle( A[ min] ==0.5)),
               phantom(0)),
          atop( atop( textstyle( "MLCT"),
                     textstyle( A[ min] ==1.0)),
               "No Mosaic"),
          atop( atop( textstyle( "MLCT"),
                     textstyle( A[ min] ==0.5)),
               "No Mosaic")))

## labels= c("Agland2000", "NLCD",
      ##   "MLCT\nA_min=1.0", "MLCT\nA_min=0.5",
      ##   "MLCT\nA_min=1.0\nNo Mosaic", "MLCT\nA_min=0.5\nNo Mosaic"))


## covers in columns
## areasCt <- cast( areasDf, .id ~ X2, subset= X2 != "total", sum, margins="grand_col")
## rownames( areasCt) <- areasCt[, ".id"]
## areasCt <- areasCt[, -1]
## areasCt[, c( names( peelClasses), "(all)")]

## covers in rows
areasCt <- cast( areasDf, class ~ map,
                value= "acres",
                subset= class != "total",
                sum,
                margins="grand_row")[, -1]
rownames( areasCt) <- levels( areasDf$class)
#areasCt <- areasCt[, -1]
#areasCt <- areasCt[ c( names( peelClasses), "(all)"), rasterNames]

          

      
      
@ %def 


@
<<tab_areas, results=tex>>=


local({
  colnames( areasCt) <- c( "Agland2000", "NLCD",
                          "\\pbox[c][][c]{3in}{Aggregated\\\\$A_{min}=0.5$}",
                          "\\pbox[c][][c]{3in}{Aggregated\\\\$A_{min}=1.0$}",
                          "\\pbox[c][][c]{3in}{No Mosaic\\\\$A_{min}=0.5$}",
                          "\\smallskip\\pbox[c][][c]{3in}{No Mosaic\\\\$A_{min}=1.0$}")
  print( xtable( areasCt / 10^6, 
                caption= "Total Acreages by Map and Cover", 
                label= "tab:areas",
                digits= 1),
        add.to.row= list( 
          pos= list( 0, nrow( areasCt)),
          command= rep("\\noalign{\\smallskip}", times= 2)),
        size= "small",
        sanitize.colnames.function= function(x) x)
})



@ %def 

\begin{figure}[hpt] 
\begin{center} 

<<fig_areas>>= 

if( overwriteFigures) {  
  setwd( texWd)
  my.ggsave( "fig_areas.pdf", plot= areasPlot)
}


@ 

\includegraphics{fig_areas}
\end{center} 
\caption{Total Acreages by Map and Cover}
\label{fig:areas} 
\end{figure} 


After decomposing the mosaic class The MLCT indicates
\Sexpr{printAreas( areasCt[ "crop", "nomos05"])} of cropland for
$A_{min}=0.5$ and \Sexpr{printAreas( areasCt[ "crop", "nomos1"])} for
$A_{min}=1.0$ in the cUSA in 2001. 

Pasture indicated by Aglands2000 appears to be a broader
classification than that of the NLCD's pasture class because much of
the grazing land east of the Mississippi river counted in the
Aglands2000 pasture map is absent in the NLCD pasture class.

Aglands2000 indicates roughly
\Sexpr{printAreas(areasDf["crop","agland"])} of cropland.  The
inability of the MLCT data set to resolve rural transportation
networks, minor settlements, and small water or wetland features is a
major contribution to the surplus of cropland acreage indicated by the
MLCT.  Due to its greater resolution, ~30m vs. ~500m, the NLCD is
better suited at discerning developed areas in rural landscapes
ranging from rural roads to farmsteads to small communities that do
not show up in the MLCT data. There is a total area of roughly 74 Ma
(30 Mha) of development remaining after subtracting the MLCT urban
class from all developed classes in the NLCD where the NLCD shows
greater development after they have both been aggregated to the
5-arcmin grid. Applying this area as an offset to the cropland area in
Aglands2000 brings us closer to the expected acreage under cultivation
in 2001, although this assumes that all of that development intersects
with MLCT cropland area.


The purpose for processing the MLCT for two values of $A_{min}$ as
described in the previous chapter is to evaluate whether or not
information from the secondary cover type contributes positively to
the accuracy of the data set we seek to synthesize.  The primary
objective of this synthesis is to achieve accuracy in cropland
distribution.  Because the cropland layer in the Agland2000 data set
is derived from county-level production census statistics we adopt
this as the ground truth and will endeavor to adjust our product
accordingly.  Although MLCT overstates cropland acreage for both
$A_{min}=0.5$ and $A_min=1.0$ the discrimination among the two is made
by the distribution of errors rather than the aggregate error.

\missingfigure{error map for ``nomos'' vs. Agland2000 crop}

These maps show the cell-by-cell differences between the MLCT-derived
data set that we have calculated after mosaic decomposition and the
Agland2000 cropland map.  TO summarize and compare these errors we
calculate the root of the mean squared error (RMSE) given by:

$$
\operatorname{RMSE}=\sqrt{\frac{\sum_{i=1}^{n}(\hat\theta_i-\theta_i )^2}{n}}
$$

where $\hat\theta_i$ are the predictions derived from the respective
MLCT derivations and $\theta_i$ are the observations taken from the
Agland2000 data set.


@
<<rmse>>=


rmseDf <- ldply( list("nomos05", "nomos1"),
                function( brickName) {
                  rmseRast( getPeelBand( get( brickName), "crop"),
                           unstack( agland)[[1]])
                })
rmseDf <- cbind( c( 0.5, 1.0), rmseDf)
colnames( rmseDf) <- c( "$A_{min}$", "RMSE")

cropScatDf <- 
  data.frame( as( stack( getPeelBand( nomos05, "crop"),
                        getPeelBand( nomos1, "crop"),
                        unstack( agland)[[1]],
                        mask(acres, cusaMask)),
                 "SpatialGridDataFrame"))
colnames(cropScatDf) <-
  c( "nomos05", "nomos1", "agland", "acres", "lon", "lat")
cropScatDf$weight <- with( cropScatDf, acres/ max(acres))


if( overwriteFigures) scatPlot1 <-
  ggplot( data=
         cropScatDf, ##[ sample( 1:nrow(cropScatDf),
                     ##       round( nrow(cropScatDf) *0.05)),],
         aes( agland, nomos1,
             size= weight)) +
  geom_point( alpha= 0.03) +
  scale_area( limits= c(0.7, 1),
             breaks= seq( 0.7, by= 0.1),
             to= c(0.7, 1) *6) +
  geom_abline( size= 2,
              alpha= 0.4) +
  theme_bw() +
  scale_x_continuous( "Agland2000",
                     limits= c( 0, 1),
                     expand= c( 0.025, 0)) +
  scale_y_continuous( "MLCT, A_min = 1.0",
                     limits= c( 0, 1),
                     expand= c( 0.025, 0)) +
  coord_equal() +
  opts( legend.position= "none")


@

\begin{figure}[hpt]
  \begin{center} 

<<fig_scatplot1>>= 

if( overwriteFigures) {
  setwd( texWd)
  my.ggsave( "fig_scatPlot1.png",
         plot= scatPlot1)
}

@ 

\includegraphics{fig_scatPlot1}
  \end{center} 
  \caption{Scatter plot of MLCT crop ($A_{min}=1.0$, no mosaic) versus Agland2000 cropland}
  \label{fig:scatplot1} 
\end{figure} 

\begin{figure}[hpt]
  \begin{center} 


<<fig_scatplot05>>= 

if( overwriteFigures) {
  setwd( texWd)
  my.ggsave( "fig_scatPlot05.png",
         plot= scatPlot1 +
         aes(agland, nomos05, size=weight) +
         scale_y_continuous( "MLCT, A_min = 0.5",
                            limits= c( 0, 1),
                            expand= c( 0.025, 0)))
}



@ 

\includegraphics{fig_scatPlot05}
  \end{center} 
  \caption{Scatter plot of MLCT crop ($A_{min}=0.5$, no mosaic) versus Agland2000 cropland}
  \label{fig:scatplot05} 
\end{figure} 

@ 
<<table_rmse, results=tex>>=

print( xtable( rmseDf,
              caption= "RMSE, MLCT vs. Agland2000 crop",
              label= "tab:rmse",
              digits= c( 0, 1, 3)),
      include.rownames= FALSE,
      sanitize.colnames.function= function(x) x)

@ %def 

The results on Table \ref{tab:rmse} indicate that $A_{min}=0.5$ is
more representative of the distribution of cropland because although
the total area indicated is higher there is less error on a
cell-by-cell basis indicating that it does a better job of
representing the spatial distribution than $A_{min}=1.0$.  Later when
we recalculate the cell proportions by accepting the values for
cropland area from Agland2000 as truth we can expect minimal
distortion in reconciling its landscape with that given by MLCT.  From
this point forward we will consider only the statistics derived from
setting $A_{min}=0.5$ for the aggregation of the MLCT data due to this
improved fit with Agland2000 cropland and its full consideration of
all information imparted by the MLCT data.


\section{NLCD Offsets}
\label{sec:nlcd_offsets}


From Table \ref{tab:areas} it is apparent that the MLCT results are
negatively biased in the areas assigned to water, wetland, and urban
features relative to the NLCD.  It is clear from visual inspection
that features of these classes tend to have smaller characteristic
dimensions which causes them to be overlooked in the the MLCT
classification.  The most obvious example are the rural transportation
networks in areas delineated by the Public Land Survey System (PLSS)
where roads have been laid out on a regular grid of square miles
called sections.  In the PEEL classification this infrastructure is
included in the urban class as another form of developed land.

The process of merging this information from the NLCD is as follows:

\begin{enumerate}
  \item Create a mask comprised of pixels classified as water, wetland,
    or urban in the reclassified NLCD
  \item Resample the MLCT layers to NLCD resolution (\~1.25 arcsecs)
    using this mask
  \item Compute class-by-class offsets by accepting each NLCD pixel in
    the mask as a positive increment and each in the MLCT as a negative
    in proportion to the shares given by the formulas for $A_{pri}$ and
    $A_{sec}$.  Pixels outside the mask or where the data sets agree are
    assigned a zero value in this step.
  \item Aggregate these offsets to 5-arcmin resolution by taking the
    mean of offset values across a given output grid cell
  \item Add these offsets to the aggregated MLCT maps prior to the
    mosaic decomposition step
  \item Recalculate the mosaic decomposition
\end{enumerate}

<<offsets_init>>=

## rebuild the thumb object from the previous chapter

## thumb <- mlctList( "thumb_2001_lct1.tif", 
##                    "thumb_2001_lct1_sec.tif", 
##                    "thumb_2001_lct1_pct.tif")

thumbRasters <- list.files( dataPath, "thumb_2001.*_(reclass|pct)",
                           recursive=TRUE, full.names=TRUE)[ c(2,3,1)]
names( thumbRasters) <- names(formals( mlctList))

thumb <- do.call( mlctList, as.list( thumbRasters))

thumb$Amin <- 0.5
thumb$Ap <- raster( list.files( dataPath, "thumb_Amin_0.5.tif", full.names=TRUE))
thumb$agg <- brick( list.files( dataPath, "thumb_Amin_0.5_agg.tif", full.names=TRUE))

thumbNlcd <- list( pri=
                  raster( list.files( dataPath, "thumbNlcd_reclass.tif",
                                     recursive=TRUE, full.names=TRUE)))
@ 



@ 
<<offsets_mask>>=

setwd( dataPath)

thumbNlcdMask <-
  if( overwriteRasters) {
    calc( thumbNlcd$pri,
         function( x) {
           ifelse( x %in% peelClasses[ c( "water", "wetland", "urban")],
                  x, NA)
         },
         datatype= "INT2U",
         overwrite= TRUE,
         filename= "thumbNlcdMask.tif",
         progress= "text")
  } else {
    raster( "thumbNlcdMask.tif")
  }
thumbNlcdMask <- setMinMax( thumbNlcdMask)

@ 

\missingfigure{ NLCD mask facet map}

<<offsets_resample>>=


thumbResamp <-
  if( overwriteRasters) {
    resample( stack( thumb$pri, thumb$sec),
             stack(thumbNlcd$pri, thumbNlcd$pri),
             method= "ngb",
             datatype= "INT2U",
             overwrite= TRUE,
             filename= "thumbResamp.tif",
             progress= "text")
  } else raster( "thumbResamp.tif")
thumbResamp <- setMinMax( thumbResamp)


thumbResampAp <-
  if( overwriteRasters) {
    resample( thumb$Ap, thumbNlcd$pri,
             method="ngb",
             datatype= "FLT4S",
             overwrite= TRUE,
             filename= "thumbResampAp.tif",
             progress= "text")
  } else raster( "thumbResampAp.tif")

thumbNlcdMlct <-
  if( overwriteRasters) {
    mask( stack( thumbResamp, thumbResampAp),
         thumbNlcdMask,
         #datatype= "INT2U",
         overwrite= TRUE,
         filename= "thumbNlcdMlct.tif",
         progress= "text")
  } else raster( "thumbNlcdMlct.tif")
thumbNlcdMlct <- setMinMax( thumbNlcdMlct)
@ 

\missingfigure{ MLCT resampled and masked facet(?) map(s?)}

@
<<offsets_calc>>=



##crosstab( thumbNlcdMlct, thumbNlcdMask)


thumbOffsetsInputAp <-
  if( overwriteRasters) {
    brick( stack( thumbNlcdMlct,
                 thumbNlcdMask),
          filename= "thumbOffsetsInputAp.tif",
          overwrite= TRUE,
          progress= "text")
  } else brick( "thumbOffsetsInputAp.tif")




##offsetCalcFunWater <- offsetCalcFun(0)


# The next few assignments end with "Ap" to signify that
# the variable A_p is considered, thereby incorporating
# information from both primary and secondary covers.

# Prior implementation only considered primary cover in
# calculating these offsets

offsetCalcFunAp <- function( class) {
  fun <- function( st) {
    pri <- st[ 1]
    sec <- st[ 2]
    Ap <- st[ 3]
    nlcd <- st[ 4]
    result <- matrix( 0, nrow= 1, ncol= 9)
    if( !is.na( pri) &&nlcd ==class) {
      result[ 1, pri +1] <- -Ap
      result[ 1, sec +1] <- Ap -1
      result[ 1, nlcd +1] <- result[ 1, nlcd +1] +1
    }
    result
  }
  fun
}

thumbOffsetsAp <-
  sapply( grep( "water|wetland|urban",
               names(peelClasses), value=TRUE),
         function( cover) {
           fn <- paste( "thumbOffsetsAp",
                  paste( cover, "tif", sep= "."),
                  sep= "_")
           print( paste(cover, fn))
           if( overwriteRasters || !( file.access( fn) ==0)) {
             calc( thumbOffsetsInputAp,
                  fun= offsetCalcFunAp( peelClasses[[ cover]]),
                  datatype= "FLT4S",
                  overwrite= TRUE,
                  filename= fn,
                  progress= "text")
           } else brick( list.files( patt=fn, full.names= TRUE))
         })


thumbOffsetsAp <-
  sapply( names( thumbOffsetsAp),
         function( cover) {
           fn <- paste( "thumbOffsetsAp",
                       cover, "agg.tif", sep= "_")
           print( paste( cover, fn))
           if( overwriteRasters || !( file.access( fn) ==0))
             aggregate( thumbOffsetsAp[[ cover]],
                       fact= 5/60 /res( thumbOffsetsAp[[ cover]]),
                       expand= FALSE,
                       filename= fn,
                       datatype= "FLT4S",
                       overwrite= TRUE,
                       progress= "text")
           else brick( list.files( patt=fn, full.names= TRUE))
         })

thumbOffsetsAp <-
  sapply( thumbOffsetsAp,
         function( r) {
           layerNames( r) <- names( peelClasses)
           r
         })


## thumbOffsetsApTotal <-
##   writeRaster( thumbOffsetsAp$water +
##               thumbOffsetsAp$wetland +
##               thumbOffsetsAp$urban,
##               filename= "thumbOffsetsAp_total.tif",
##               overwrite=TRUE)


thumbOffsetsApTotal <-
  do.call( overlay,
          c( unlist( thumbOffsetsAp, use.names= FALSE),
               fun= sum,
               filename= "thumbOffsetsAp_total.tif",
               overwrite= TRUE,
               progress= "text"))

thumbAdj <- thumb
thumbAdj$agg <- 
  overlay( thumbAdj$agg, thumbOffsetsApTotal,
          fun= sum,
          filename= "thumbAdj.tif",
          overwrite= TRUE)

                  
thumbAdj  <- decomposeMosaic( thumbAdj, overwrite= overwriteRasters, progress= "text")

@ 

\missingfigure{Facet map of thumb offsets}

\missingfigure{Difference map, thumb adjusted vs. original after mosaic decomposition}


Due to performance constraints it was not possible to carry out this
operation on the full cUSA study area.  The equivalent operation of
resampling the MLCT to the NLCD resolution of 1.25 arcsecs,
calculating the offsets for water, wetland, and urban (developed)
features implemented in a Bash script for use in the GRASS GIS
environment is given in the appendix.

\todo{Reference / hyperlink NLCD offset GRASS script in appendix}


The resulting offsets are added to the aggregated fractions calculated
from the MLCT with $A_{min}=0.5$.  


<<cusa_offset>>=

offsetFile <- path.expand( paste( rasterWd, "nlcd_offset.tif", sep="/"))

offset <- brick( offsetFile)
offset <- setMinMax( offset)
layerNames(offset) <- names( peelClasses)

## mlctAdj <- list( Amin=0.5)
## mlctAdj$agg <- 
##   overlay( agg05, offset,
##           fun= sum,
##           filename= "agg05Adj.tif",
##           overwrite= TRUE)

mySum <- function( ...) {
  res <- sum( ...)
  res[ res > 1] <- 1
  res[ res < 0] <- 0
  res
}
                                        # use this function to clean up any over/underruns
                                        # resulting from floating point math

mlctAdj <- list( Amin=0.5)

mlctAdj$agg <-
  if( overwriteRasters) {
    overlay( agg05, offset,
            fun= mySum,
            filename= "agg05Adj_mySum.tif",
            overwrite= TRUE)
  } else brick( list.files( getwd(), patt= "agg05Adj_mySum.tif", full.names= TRUE))

layerNames( mlctAdj$agg) <- names( peelClasses)

mlctAdj  <- decomposeMosaic( mlctAdj, overwrite= overwriteRasters, progress= "text")

@ 

\missingfigure{Facet map of cUSA NLCD offsets}




<<areas2>>=

# reuse area table code from above; better to implement a function?

rasterNames2 <- c( "agland", "nlcd", "agg05", "nomos05",
                  "offset", "mlctAdj$agg", "mlctAdj$nomos")

dataSets2 <- sapply( rasterNames2,
  function( n) eval( parse( text=n)))

areas2 <- llply( dataSets2,
  function( d) {
    res <- cellStats( d *acres, sum)
    names( res) <- layerNames( d)
    res
  })

areasDf2 <- ldply( areas2, function( a) {
  melt( t( as.data.frame( a)))
})
areasDf2 <-
  areasDf2[, c( 1, 3, 4)]
colnames( areasDf2) <-
  c( "map", "class", "acres")
areasDf2$map <-
  factor( areasDf2$map,
         levels= rasterNames2)

## unused
## areasPlot2 <-
##   qplot( map, acres /10^6,
##         data= subset(areasDf2,
##           class != "total" & map != "offset"),
##         geom="bar", position= "stack",
##         fill= class,
##         stat="summary", fun.y="sum") +
##   scale_fill_manual( "",
##                     values= peelLegend, 
##                     breaks= names( peelClasses)) +
##   scale_y_continuous( "Ma",
##       limits= c(0,2000)) +
##   theme_bw()



## covers in rows

##areasCt2 <- cast( areasDf2, X2 ~ .id, subset= X2 != "total", sum, margins="grand_row")

areasCt2 <- cast( areasDf2,
                 class ~ map,
                 subset= class != "total",
                 value= "acres",
                 sum,
                 margins="grand_row")

rownames( areasCt2) <- areasCt2[, "class"]
areasCt2 <- areasCt2[, -1]
areasCt2 <- areasCt2[ c( names( peelClasses), "(all)"), rasterNames2]

@ 

Following these algebraic acrobatics it seems prudent to check our
accounting with some simple arithmetic.  Working backwards from the
final result of adding NLCD-derived offsets to the raster stack
derived from the MLCT with $A_{min}=0.5$ and decomposing the remaining
mosaic fractions into their constituent cover types, subtracting the
deltas that came from the mosaic decomposition, subtracting offsets
calculated from the NLCD, and subtracting the aggregated MLCT data
from the previous chapter 
\todo{hyperlink to section where MLCT was aggregated} 
should produce zeroes everywhere, plus or minus the noise of floating
point math.


<<restack_check>>=

## check that everything balances
## output of decomposeMosaic is not brick()ed properly
## in the sense that the layer set is incomplete
## and out of order
  
zeroes <- cusaMask
zeroes[] <- 0

restack <- function( peelBrick) {
  u <- unstack( peelBrick)
  names( u) <- layerNames( peelBrick)
  r <- do.call( stack,
          llply( names( peelClasses),
                function( cover) {
                  if( is.null( u[[ cover]]))
                    zeroes
                  else
                    u[[ cover]]
                }))
  layerNames( r) <- names( peelClasses)
  r
}
                                        # restack() takes any of the bricks/stacks from
                                        # previous functions and rearranges the layers
                                        # to match the PEEL classes, inserting layers of
                                        # zeroes as needed


## check <- llply( mlctAdj[ c("nomos", "delta", "agg")], restack)
## names(check) <- NULL
## do.call( overlay, c(check , fun=function( n, d, a) n-d-a))

restackOverlay <- function( rasterList, fun) {
  l <- llply( rasterList, restack)
  names( l) <- NULL
  do.call( overlay, c( l, fun=fun))
}
                                        # restackOverlay() runs its arguments through restack()
                                        # and applies a function to its outputs

## restackOverlay( mlctAdj[ c("nomos", "delta", "agg")],
##                function( n, d, a) n-d-a)

## restackOverlay( list( mlctAdj$agg, offset, agg05),
##                function( a2, o, a) a2-o-a)

@ 


<<results_restack_check, results=verbatim>>=

check <- restackOverlay( c( mlctAdj[ c("nomos", "delta")], offset, agg05),
               function( n, d, o, a) n-d-o-a)
layerNames(check) <- names( peelClasses)

check

@ %def 

@ 
<<table_restack_check, results=tex>>=
  
checkTable <-
  xtable( cbind( class=peelClasses,
                min=minValue( check),
                max=maxValue(check)),
         caption= "Balance of adjustment fractions and original MLCT aggregation", 
         label= "tab:restack_check")
digits( checkTable) <- c( 0, 0,-2,-2)
print( checkTable)
  
@ %def 

To assess whether the process of adding in the NLCD offsets has
improved overall cropland accuracy we can perform the same error
calculation from above and extend Table~\ref{tab:rmse} with the new
result, giving us Table~\ref{tab:rmse2}.

@ 
<<table_rmse2, results=tex>>=

                                        # add the RMSE for the new crop map
                                        # and an indication of the NLCD offsets' presence
  
rmseDf <-
  cbind( offset=c( TRUE, FALSE, FALSE),
        rbind( c( 0.5,
                 rmseRast( getPeelBand( mlctAdj$nomos, "crop"),
                          unstack( agland)[[ 1]])),
              rmseDf))

                                        # add the RMSE for the open class
rmseDf <-
  cbind( rmseDf,
        rmseOpen=ldply( list(mlctAdj$nomos, nomos05, nomos1),
                function( brickVar) {
                  rmseRast( getPeelBand( brickVar, "open"),
                           unstack( agland)[[ 2]])
                }))
colnames(rmseDf)[ c(3,4)] <- c( "$RMSE_{crop}$", "$RMSE_{open}$")

           
print( xtable( rmseDf,
              caption= "RMSE, MLCT vs. Agland2000 crop with NLCD offsets",
              label= "tab:rmse2",
              digits= c( 0, 0, 1, 3, 3)),
      include.rownames= FALSE,
      sanitize.colnames.function= function(x) x)

@ %def 

\todo[caption=Should the RMSE tables be rearranged?]{Would it make
  more sense to have the row order and independent variables (first
  three) reversed in Table \ref{tab:rmse} and \ref{tab:rmse2}?}

Seeing that this modifcation to the data set has improved our overall
accuracy of the distribution of croplands the next step is to examine
the total areas for all classes compared with the input data sets.  


<<tab_areas2, results=tex>>=


local({
  colnames( areasCt2) <- c( "Agland2000", "NLCD", "MLCT", 
                           "\\pbox[c][][c]{3in}{MLCT\\\\No Mosaic}",
                           "\\pbox[c][][c]{3in}{NLCD\\\\Offsets}", 
                           "\\pbox[c][][c]{3in}{MLCT\\\\Adjusted}",
                           "\\pbox[c][][c]{3in}{\\smallskip{}MLCT\\\\Adjusted\\\\No Mosaic}")
  print( xtable( areasCt2 / 10^6, 
                caption= "Effect of NLCD offsets on total acreages, $A_{min}=0.5$",
                label= "tab:areas2",
                digits= 1),
        size= "small",
        add.to.row= list( 
          pos= list( 0, nrow( areasCt)),
          command= rep("\\noalign{\\smallskip}", times= 2)),        
        sanitize.colnames.function= function(x) x)
        ##,
        ##        sanitize.text.function= function(x) x))
  ##,
  ##      floating= FALSE)
})

if( overwriteFigures) areasPlotAdj <-
  qplot( map, acres /10^6,
        data= subset( areasDf2,
          class != "total" & map != "offset"),
        geom="bar", position= "stack",
        fill= class,
        stat="summary", fun.y="sum") +
  scale_fill_manual( "",
                    values= peelLegend[ levels( areasDf2$class)[1:9]], #peelLegend, 
                    breaks= names( peelClasses)) +
  scale_y_continuous( "Ma",
      limits= c(0,2000)) +
  theme_bw() +
  scale_x_discrete( "",
      limits= rasterNames2[ rasterNames2 != "offset"],
      breaks= rasterNames2[ rasterNames2 != "offset"],
      labels= expression("Agland2000", "NLCD",
          atop( atop( textstyle( "MLCT"),
                     textstyle( A[ min] ==0.5)),
               phantom(0)),
          atop( atop( textstyle( "MLCT"),
                     textstyle( A[ min] ==0.5)),
               "No Mosaic"),
          atop( atop( textstyle( "MLCT"),
                     textstyle( A[ min] ==0.5)),
               "Adjusted"),
          atop( atop( textstyle( "MLCT"),
                     textstyle( A[ min] ==0.5)),
               scriptstyle( "Adjusted, No Mosaic"))))

      ## labels= c("Agland", "NLCD",
      ##   "MLCT\nA_min=0.5", "MLCT\nA_min=0.5\nNo Mosaic",
      ##   "MLCT\nAdjusted", "MLCT\nAdjusted\nNo Mosaic"))



cropScatAdjDf <- 
  data.frame( as( stack(getPeelBand( mlctAdj$nomos, "crop"),
                        unstack( agland)[[1]],
                        mask(acres, cusaMask)),
                 "SpatialGridDataFrame"))
colnames(cropScatAdjDf) <-
  c( "mlctAdj", "agland", "acres", "lon", "lat")
cropScatAdjDf$weight <- with( cropScatAdjDf, acres/ max(acres))


if( overwriteFigures) scatPlotAdj <-
  ggplot( data=
         cropScatAdjDf, ##[ sample( 1:nrow(cropScatAdjDf),
                       ##         round( nrow(cropScatAdjDf) *0.05)),],
         aes( agland, mlctAdj,
             size= weight)) +
  geom_point( alpha= 0.03) +
  scale_area( limits= c(0.7, 1),
             breaks= seq( 0.7, by= 0.1),
             to= c(0.7, 1) *6) +
  geom_abline( size= 2,
              alpha= 0.4) +
  ##  stat_smooth( method= "lm",
  ##              se= FALSE,
  ##              size= 3,
  ##              alpha= 0.2) +
  theme_bw() +
  scale_x_continuous( "Agland2000",
                     limits= c( 0,1),
                     expand= c( 0.025,0)) +
  scale_y_continuous( "MLCT Adjusted",
                     limits= c( 0,1),
                     expand= c( 0.025,0)) +
  coord_equal() +
  opts( legend.position= "none")



@

\begin{figure}[hpt]
  \centering

 
<<fig_offsets>>=
 
if( overwriteFigures) {
  offsetsPlot <-
    qplot( class, acres /10^6, 
        data= subset( areasDf2, map == "offset"),
        geom= "bar",
        fill= class) +
    scale_fill_manual( "",
        values= peelLegend, 
        breaks= names( peelClasses)) +
    scale_y_continuous( "Ma") +
    scale_x_discrete( "") +
    coord_flip() +
    theme_bw()
  setwd( texWd)
  my.ggsave( "fig_offsets.pdf",
         plot= offsetsPlot)
}



@ %def 

  \includegraphics{fig_offsets}
  \caption{Total offsets calculated from NLCD}
  \label{fig:offsets}
\end{figure}


\begin{figure}[hpt]
  \centering


@ 
<<fig_areasAdj>>=

if( overwriteFigures) {
  setwd( texWd)
  my.ggsave( "fig_areasAdj.pdf", plot= areasPlotAdj)
}

@ %def
  \includegraphics{fig_areasAdj}
  \caption{Area totals after NLCD adjustment}
  \label{fig:areasAdj}
\end{figure}

\begin{figure}[hpt] 
  \begin{center} 

<<fig_scatPlotAdj>>= 

if( overwriteFigures) {
  setwd( texWd)
  my.ggsave( "fig_scatPlotAdj.png",
         plot= scatPlotAdj)
}


  
@ 

    \includegraphics{fig_scatPlotAdj}
  \end{center} 
  \caption{Scatter plot of MLCT adjusted crop versus Agland2000 cropland}
  \label{fig:scatPlotAdj} 
\end{figure} 



<<agc, eval=FALSE>>=

## thumbAgland <- crop( agland,
##                     extent(-83.5, -(82+25/60), 42+55/60, 44+5/60),
##                     filename= "thumbAgland.tif",
##                     progress="text")

nomosCrop <- getPeelBand( mlctAdj$nomos, "crop")
aglandCrop <- unstack( agland)[[ 1]]
## ones <- zeroes
## ones[] <- 1

## noncropFactor <- ( ones -aglandCrop) /( ones -nomosCrop)

noncropFactor <-
  overlay( aglandCrop, nomosCrop, fun=
          function( a, n) {
            ## if( is.na( a) & !is.na( n)) 1
            ## else ( 1 -a) /( 1 -n)
            ifelse( is.na( a) & !is.na( n), 1,
                   ( 1 -a) /( 1 -n))
          })

## cropFactor <- aglandCrop /nomosCrop

cropFactor <-
  overlay( aglandCrop, nomosCrop, fun=
          function( a, n) {
            ifelse( is.na( a) & n >0, 1,
                   ifelse( is.na( a) |
                          a >=0 & n ==0, 0, a /n))
          }  )

            ## ## if( is.na( a) & !is.na( n)) 1
            ## ## else if( a >0 & n ==0 ) 0
            ## ## else a /n
            ## ones <- is.na( a) & !is.na( n)
            ## factor <- ifelse( a >0 & n ==0, 0, a /n)
            ## factor[ ones] <- 1
            ## factor

nomosClasses <- layerNames(mlctAdj$nomos)[-9]
                                        # leaves out 'total'
                                        # mosaic is already gone
factorStack <- 
  stack( llply( nomosClasses =="crop",
               function( isCrop) {
                 if( isCrop)
                   cropFactor
                 else
                   noncropFactor
               }))

cropOffset <-
  overlay( aglandCrop, nomosCrop, fun=
          function( a, n) {
            ifelse( is.na( a) & n >= 0, 0,
                   ifelse( a >0 & n ==0, a, 0))
          })

            ## if( is.na( a) & n > 0) n
            ## else if( a >0 & n ==0) a
            ## else 0


offsetStack <-
  stack( llply( nomosClasses =="crop",
               function( isCrop) {
                 if( isCrop)
                   cropOffset
                 else
                   zeroes
               }))


## aglandComplete <- mlctAdj$nomos *factorStack +offsetStack

aglandComplete <-
  if( overwriteRasters) {
    overlay( stack( unstack( mlctAdj$nomos)[ -9]),
            factorStack,
            offsetStack, 
            fun= function( x, m, b) m *x +b,
            filename= "aglandComplete.tif",
            overwrite= TRUE,
            progress= "text")
  } else brick( list.files( rasterWd,
                         patt="^aglandComplete.tif$",
                         full.names=TRUE))
layerNames( aglandComplete) <- names(peelClasses)[-8]

agcMap <- coverMaps( aglandComplete, 0.4) +
  coord_equal() +
  facet_grid( variable ~ .)


@ 

\begin{figure}[hpt] 
\begin{center} 

<<fig_agc, eval=FALSE>>= 

setwd( texWd)
my.ggsave( "fig_agc.png", width=4.5, height=8)

## png( file="fig_agc.png",
##     height= 8, width= 4.5, units= "in"  # no effect
##     res= 300)
## print( agcMap)
## dev.off()

@ 

\includegraphics{fig_agc}
\end{center} 
\caption{Agland Complete cover maps} 
\label{fig:agc} 
\end{figure} 


@

blah blah blah

@ 
<<table_rmse3, results=tex, eval=FALSE>>=

setwd( rasterWd)  

rmseDf <- 
  cbind( agland=c( TRUE, rep(FALSE, times=3)),
        rbind( c( TRUE, 0.5,
                 rmseRast( getPeelBand( aglandComplete, "crop"),
                          unstack( agland)[[ 1]]),
                 rmseRast( getPeelBand( aglandComplete, "open"),
                          unstack( agland)[[ 2]])),
              rmseDf))
rmseDf <- within(rmseDf, offset <- as.logical( offset))
                                        # had to change offset column back
                                        # to true/false;  maybe this can be
                                        # avoided with list() instead of c()

rmseXt <- xtable( rmseDf,
                 caption= "RMSE of Agland Complete vs. Agland2000",
                 label= "tab:rmse3",
                 digits= c( 0, 0, 0, 1, 3, 3))
                                        # looks like some kind of bug in xtable()
                                        # manual correction:
rmseXt$agland <- rmseDf$agland
rmseXt$offset <- rmseDf$offset

print( rmseXt,
      include.rownames= FALSE,
      sanitize.colnames.function= function(x) x)

@ %def 


<<tab_areas3, results=tex, eval=FALSE>>=

areasCt3 <- acreageTable( c( rasterNames2[ c( 1, 2, 4, 7)], "aglandComplete"))

local({
  colnames( areasCt3) <-
    c( "Agland2000", "NLCD",
      "\\pbox[c][][c]{3in}{MLCT\\\\No Mosaic}",
      "\\pbox[c][][c]{3in}{\\smallskip{}MLCT\\\\Adjusted\\\\No Mosaic}",
      "AgC")
  print( xtable( areasCt3 / 10^6, 
                caption= "Agland Complete (AgC) acreages, $A_{min}=0.5$",
                label= "tab:areas3",
                digits= 1),
        size= "small",
        add.to.row= list( 
          pos= list( 0, nrow( areasCt)),
          command= rep("\\noalign{\\smallskip}", times= 2)),        
        sanitize.colnames.function= function(x) x)
  ##,
  ##      floating= FALSE)
})


@

<<crop_cats, eval=FALSE>>=

setwd( dataPath)
##cropCats <- rep( NA, times=10)
cropCats <-
  c("cereals", "field_crop", "forage", "maize",
    "rice", "shrub_crop", "soybean", "sugarcane",
    "tree_crop", "wheat")
names( cropCats) <- cropCats

cropCatsPeel <- cropCats
cropCatsPeel[ c( "cereals", "field_crop",
                "maize", "rice", "soybean",
                "sugarcane", "wheat")] <- "crop"
cropCatsPeel[ "forage"] <- "open"
cropCatsPeel[ "shrub_crop"] <- "shrub"
cropCatsPeel[ "tree_crop"] <- "forest"

cropCatsPeel <-
  list( crop= c( "cereals", "field_crop",
                "maize", "rice", "soybean",
                "sugarcane", "wheat"),
       open= "forage",
       shrub= "shrub_crop",
       forest= "tree_crop")
                     
cropCats <- llply(  cropCats, function(c) {
  raster( paste( c, "tif", sep="."))
})

cropStack <- stack( cropCats)

grep( paste( cropCatsPeel$crop, sep="|"),
)

overlay( stack( cropCats[ cropCatsPeel$crop]), fun=sum)
                                        # problem: max is 1.37
                                        # double-cropping?
                                        # what about non-crop covers?

cropOffsets <- llply( cropCatsPeel, function( catsVec) {
  if( length( catsVec) ==1) {
    cropCats[ catsVec]
  } else {
    overlay( stack( cropCats[ catsVec]), fun=sum)
  }})


@ 

\begin{comment}
\todo[inline,caption={Decide what to do with old code in Analysis
  chapter}]{The remaining code in this draft of the Analysis chapter
  has fallen out of date.  The maps are based on old data that has
  been replaced and the tables are probably not going to appear given
  that the code sections will not be evaluated.  The idea of finding
  correlations across a set of difference map still seems promising,
  so I am leaving it in the source code for now.}


To assess the impact of this step on the overall accuracy it is useful
compare the errors and biases of our newly derived ``Agland
Complete''(AgC) data set for all cover classes before and after the
adjustment of the cell-by-cell cropland areas to match Agland2000.



\SweaveOpts{ eval=FALSE}

 

<<bias>>=

## calculate RMSE/bias summaries
## comparing everything to NLCD


rmseAgc <- rmseSummary( function(c) paste(  "agc", c, sep="_"),
                       function(c) paste( "nlcd", c, sep="_"))

rmseAs00 <- rmseSummary( function(c) paste( "mlct_2001", c, "As00", sep="_"),
                        function(c) paste( "nlcd", c, sep="_"))

rmseAs05 <- rmseSummary( function(c) paste( "mlct_2001", c, "As05", sep="_"),
                        function(c) paste( "nlcd", c, sep="_"))
@ 

<<biasTab, results=tex>>=
## t( rmseAgc)
## t( rmseAs00)
## t( rmseAs05)

print( xtable( t( rmseAgc), 
              caption= "Errors and Biases of Aglands Complete relative to NLCD",
              label= "tab:ebagc",
              digits= c( 0, 2, -2, 0, 0)))

print( xtable( t( rmseAs00), 
              caption= "Errors and Biases of MLCT, $A_s = 0.0$ relative to NLCD",
              label= "tab:ebmlct00",
              digits= c( 0, 2, -2, 0, 0)))

print( xtable( t( rmseAs05), 
              caption= "Errors and Biases of MLCT, $A_s = 0.5$ relative to NLCD",
              label= "tab:ebmlct05",
              digits= c( 0, 2, -2, 0, 0)))
@

<<stack>>=
## agcAvgAcres <-
##   sapply( paste( "agc_", covers, sep=""),
##          function( map) {
##            mapRast <- raster( as.spgdf( handle( map)))
##            return( cellStats( areaAcres( mapRast), sum)
##                   /( ncell( mapRast) - cellStats( mapRast, 'countNA')))
##          })


## getting ready to plot

stackAgc <- stackHandles( grepHandles(  "^agc"))
attr( stackAgc, "layernames") <-  covers

stackNlcd <- stackHandles( grepHandles( "^nlcd"))
attr( stackNlcd, "layernames") <-  covers

stackDiff <- stackAgc -stackNlcd
attr( stackDiff, "layernames") <-  covers

@ 

\begin{figure}[hpt] 
\begin{center} 

@
<<fig_nlcd>>= 

##spgdfNlcd <- as.spgdf( stackNlcd)
##names( spgdfNlcd) <- layerNames( stackNlcd)
setwd( texWd)
png( file="fig_nlcd.png")
print( coverMaps( stackNlcd, 0.4))
dev.off()
@ 

\includegraphics{fig_nlcd}
\end{center} 
\caption{NLCD cover maps} 
\label{fig:nlcd} 
\end{figure} 

\begin{figure}[hpt] 
\begin{center} 

@ 
<<fig_diff>>=

##spgdfDiff <- as.spgdf( stackDiff)
##names( spgdfDiff) <- layerNames( stackDiff)
setwd( texWd)
png( file="fig_diff.png")
print( coverMaps( stackDiff, 0.4) + 
      scale_fill_gradientn( "diff", colours= rev( brewer.pal( 11, "BrBG")), 
                           limits= c( 0.1, -0.1),
                           breaks= seq( 0.1, -0.1, by= -0.02)))
dev.off()
@ 

\includegraphics{fig_diff}
\end{center} 
\caption{Difference maps, Aglands Complete minus NLCD} 
\label{fig:diff} 
\end{figure} 

\begin{figure}[hpt] 
\begin{center} 

@ 
<<fig_cordiff>>=

## look for correlations across the difference maps

corDiff <- cor( as.data.frame( as.spgdf( stackDiff))[,1:8])
colnames( corDiff) <- unlist( lapply( 
                                     strsplit( colnames( corDiff), "\\."), 
                                     function( x) return( x[ 2])))
rownames( corDiff) <- unlist( lapply( 
                                     strsplit( rownames( corDiff), "\\."), 
                                     function( x) return( x[ 2])))
ord <- order.dendrogram( as.dendrogram( hclust( dist( corDiff))))

corDiffPlot <- 
  ggplot( melt( corDiff),
         aes( x=X1, y=X2, fill= value)) +
  geom_tile() +
  theme_bw() +
  opts( panel.grid.minor= theme_blank(),
       panel.grid.major= theme_blank(),
       panel.background= theme_blank(),
       axis.title.x= theme_blank(),
       axis.text.x= theme_text( angle= 90, hjust=1),
       axis.title.y= theme_blank()) +
  scale_x_discrete( limits= colnames(corDiff)[ord]) +
  scale_y_discrete( limits= colnames(corDiff)[ord]) +
  scale_fill_gradientn( "cor", colours= rev( brewer.pal( 11, "BrBG")), 
                       limits= c( 1.0, -1.0),
                       breaks= seq( 1.0, -1.0, by= -0.2))


setwd( texWd)
png( file="fig_cordiff.png")
print( corDiffPlot)
dev.off()
@ 
\includegraphics{fig_cordiff}
\end{center} 
\caption{Correlations across cover type in difference maps} 
\label{fig:cordiff} 
\end{figure} 

The elements of the matrix have been reordered according to the
clustering forumla given in \citet[sec. 6.2.3]{Sarkar2008} in order to
achieve a degree of visual clustering among the correlation vectors.

\end{comment}

@ %def 
@ 
<<cleanup, eval=TRUE>>=
options( prompt= "> ", continue= "+ ", width= 80)
@ %def 

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "thesis"
%%% End: 

