% -*- mode: noweb; noweb-default-code-mode: R-mode; -*-

\SweaveOpts{ results=hide}
\SweaveOpts{ include=FALSE}
\SweaveOpts{ echo=FALSE}
\SweaveOpts{ engine=R}
\SweaveOpts{ keep.source= TRUE}
\SweaveOpts{ eval=FALSE}
\SweaveOpts{ eval=TRUE}

\graphicspath{ {analysis/} }

\chapter{Analysis}
\label{cha:analysis}

% , eval=TRUE>>=

<<init>>=

options( prompt= " ", continue= " ", width= 60)
options(error= function(){
  recover()
  options( prompt= "> ", continue= "+ ", width= 80)
})
  
source( "~/thesis/code/analysis.R")
source( "~/thesis/code/peel.R")
source( "~/thesis/code/maps.R")

   texWd <- path.expand( "~/thesis/analysis")
rasterWd <- path.expand( "~/thesis/data/analysis")
dataPath <- path.expand( "~/thesis/data")
setwd( rasterWd)

overwriteRasters <- TRUE
overwriteFigures <- TRUE

                                        # studyArea used to work out RMSE
                                        # calcs and tables
##studyArea <- "thumb"
studyArea <- "mlct"
                                        # bands are numbered from one but
                                        # classes from zero.  Used for stacks/brick
                                        # where bands correspond to classes
peelBands <- peelClasses +1

                                        # mask and agland exported from GRASS
                                        # no need to mask or crop
cusaMask <- raster( "mask_cusa.tif")
cusaExtent <- extent( cusaMask)
thumbExtent <- extent( -( 83 +30 /60), -( 82 +25 /60),
                          42 +55 /60,     44  +5 /60 )

                                        # default raster() output
                                        # has geographic proj, full extent
                                        # by default
world <- raster()
res(world) <- 5/60

grid <- raster( cusaMask)
grid[] <- cellsFromExtent( world, grid)
grid <- raster::mask( grid, cusaMask)

nulls <- raster( cusaMask)
nulls[] <- NA

zeroes <- raster( cusaMask)
zeroes[] <- 0

ones <- raster( cusaMask)
ones[] <- 1

if( studyArea == "thumb") {
  cusaMask <- crop( cusaMask, thumbExtent)
}
acresFile <- paste( "acres",
                   paste( studyArea, ".tif", sep=""),
                   sep="_")
if( overwriteRasters) {
  acres <- area( cusaMask) *247.105381
  acres <- writeRaster( acres,
                       filename= acresFile,
                       overwrite= TRUE)
} else acres <- raster( acresFile)

agland <- stack( list.files( paste( dataPath, "agland", sep="/"),
                            patt= "(cropland|pasture).tif$",
                            full.names= TRUE))
layerNames(agland) <- c("crop", "open")
agland <- setMinMax( agland)
if( studyArea == "thumb") {
  agland <- crop( agland, thumbExtent)
}

agg05 <-
  brick( list.files( dataPath,
                    patt= paste( studyArea, "_Amin_0.5_agg.tif", sep=""),
                    full.names= TRUE))
layerNames( agg05) <- names( peelClasses)

nomos05 <-
  brick( list.files( dataPath,
                    patt= paste( studyArea, "_Amin_0.5_nomosaic.tif", sep=""),
                    full.names= TRUE))
layerNames( nomos05) <- c( names( peelClasses)[ -8], "total")

agg1 <-
  brick( list.files( dataPath,
                    patt= paste( studyArea, "1_agg.tif", sep=""),
                    full.names= TRUE)) 
layerNames( agg1) <- names( peelClasses)

nomos1 <-
  brick( list.files( dataPath,
                    patt= paste( studyArea, "1_Amin_1_nomosaic.tif", sep=""),
                    full.names= TRUE))
layerNames( nomos1) <- c( names( peelClasses)[ -8], "total")


nlcd <-
  brick( sapply( names( peelClasses),
                function( cover) {
                  if( cover == "mosaic") {
                    zeroes
                  } else {
                    fn <-
                      list.files( paste( dataPath, "nlcd",
                                        sep = "/"),
                                 patt= paste( "nlcd", cover, "5min.tif$",
                                             sep = "_"),
                                 full.names= TRUE)
                    crop( raster( fn), cusaMask)
                  }}))


nlcd <- writeRaster( nlcd,
                    filename= paste( path.expand(rasterWd), "nlcd.tif", sep= "/"),
                    overwrite= TRUE)

layerNames(nlcd) <- names(peelClasses)


rasterNames <- c( "agland", "nlcd", "agg05", "agg1", "nomos05", "nomos1")

dataSets <- sapply( rasterNames, function( n) eval( parse( text=n)))

areas <- llply( dataSets,
function( d) {
  res <- cellStats( d *acres, sum)
  names( res) <- layerNames( d)
  res
})

## llply( areas, function( a) melt( a, value.name= deparse( substitute( a))))

areasDf <-
  ldply( areas, function( a) {
    melt( t( as.data.frame( a)))
  })
areasDf <-
  areasDf[, c( 1, 3, 4)]
colnames( areasDf) <-
  c( "map", "class", "acres")
areasDf$map <-
  factor( areasDf$map,
         levels= rasterNames)

## causes things to be in the wrong order
## areasDf$class <-
##   factor( areasDf$class,
##          levels= c( names( peelClasses), "total"))

if( overwriteFigures) areasPlot <-
  qplot( map, acres /10^6,
        data= subset(areasDf, class != "total"),
        geom="bar", position= "stack",
        fill= class,
        stat="summary", fun.y="sum") +
  scale_fill_manual( "",
                    values= peelLegend, #peelLegend[ levels( areasDf$class)[1:9]],
                    breaks= names( peelClasses)) +
  scale_y_continuous( "Ma",
      limits= c(0,2000)) +
  theme_bw() +
  scale_x_discrete( "",
      limits= rasterNames[ c( 1, 2, 4, 3, 6, 5)],
      breaks= rasterNames[ c( 1, 2, 4, 3, 6, 5)],
      labels= expression("Agland2000", "NLCD",
          atop( atop( textstyle( "MLCT"),
                     textstyle( A[ min] ==1.0)),
               phantom(0)),
          atop( atop( textstyle( "MLCT"),
                     textstyle( A[ min] ==0.5)),
               phantom(0)),
          atop( atop( textstyle( "MLCT"),
                     textstyle( A[ min] ==1.0)),
               "No Mosaic"),
          atop( atop( textstyle( "MLCT"),
                     textstyle( A[ min] ==0.5)),
               "No Mosaic")))

## labels= c("Agland2000", "NLCD",
      ##   "MLCT\nA_min=1.0", "MLCT\nA_min=0.5",
      ##   "MLCT\nA_min=1.0\nNo Mosaic", "MLCT\nA_min=0.5\nNo Mosaic"))


## covers in columns
## areasCt <- cast( areasDf, .id ~ X2, subset= X2 != "total", sum, margins="grand_col")
## rownames( areasCt) <- areasCt[, ".id"]
## areasCt <- areasCt[, -1]
## areasCt[, c( names( peelClasses), "(all)")]

## covers in rows
areasCt <- cast( areasDf, class ~ map,
                value= "acres",
                subset= class != "total",
                sum,
                margins="grand_row")[, -1]
rownames( areasCt) <- levels( areasDf$class)
#areasCt <- areasCt[, -1]
#areasCt <- areasCt[ c( names( peelClasses), "(all)"), rasterNames]

          

      
      
@ %def 


@
<<tab_areas, results=tex, eval=TRUE>>=


local({
  colnames( areasCt) <- c( "Agland2000", "NLCD",
                          "\\pbox[c][][c]{3in}{Aggregated\\\\$A_{min}=0.5$}",
                          "\\pbox[c][][c]{3in}{Aggregated\\\\$A_{min}=1.0$}",
                          "\\pbox[c][][c]{3in}{No Mosaic\\\\$A_{min}=0.5$}",
                          "\\smallskip\\pbox[c][][c]{3in}{No Mosaic\\\\$A_{min}=1.0$}")
  print( xtable( areasCt / 10^6, 
                caption= "Total Acreages by Map and Cover", 
                label= "tab:areas",
                digits= 1),
        add.to.row= list( 
          pos= list( 0, nrow( areasCt)),
          command= rep("\\noalign{\\smallskip}", times= 2)),
        size= "small",
        sanitize.colnames.function= function(x) x)
})



@ %def 

\begin{figure}[hpt] 
\begin{center} 

<<fig_areas>>= 

if( overwriteFigures) {  
  setwd( texWd)
  ggsave( "fig_areas.pdf", plot= areasPlot)
}


@ 

\includegraphics{fig_areas}
\end{center} 
\caption{Total Acreages by Map and Cover}
\label{fig:areas} 
\end{figure} 


After decomposing the mosaic class The MLCT indicates
\Sexpr{printAreas( areasCt[ "crop", "nomos05"])} of cropland for
$A_{min}=0.5$ and \Sexpr{printAreas( areasCt[ "crop", "nomos1"])} for
$A_{min}=1.0$ in the cUSA in 2001. 

Pasture indicated by Aglands2000 appears to be a broader
classification than that of the NLCD's pasture class because much of
the grazing land east of the Mississippi river counted in the
Aglands2000 pasture map is absent in the NLCD pasture class.

Aglands2000 indicates roughly
\Sexpr{printAreas(areasDf["crop","agland"])} of cropland.  The
inability of the MLCT data set to resolve rural transportation
networks, minor settlements, and small water or wetland features is a
major contribution to the surplus of cropland acreage indicated by the
MLCT.  Due to its greater resolution, ~30m vs. ~500m, the NLCD is
better suited at discerning developed areas in rural landscapes
ranging from rural roads to farmsteads to small communities that do
not show up in the MLCT data. There is a total area of roughly 74 Ma
(30 Mha) of development remaining after subtracting the MLCT urban
class from all developed classes in the NLCD where the NLCD shows
greater development after they have both been aggregated to the
5-arcmin grid. Applying this area as an offset to the cropland area in
Aglands2000 brings us closer to the expected acreage under cultivation
in 2001, although this assumes that all of that development intersects
with MLCT cropland area.


The purpose for processing the MLCT for two values of $A_{min}$ as
described in the previous chapter is to evaluate whether or not
information from the secondary cover type contributes positively to
the accuracy of the data set we seek to synthesize.  The primary
objective of this synthesis is to achieve accuracy in cropland
distribution.  Because the cropland layer in the Agland2000 data set
is derived from county-level production census statistics we adopt
this as the ground truth and will endeavor to adjust our product
accordingly.  Although MLCT overstates cropland acreage for both
$A_{min}=0.5$ and $A_min=1.0$ the discrimination among the two is made
by the distribution of errors rather than the aggregate error.

\missingfigure{error map for ``nomos'' vs. Agland2000 crop}

These maps show the cell-by-cell differences between the MLCT-derived
data set that we have calculated after mosaic decomposition and the
Agland2000 cropland map.  TO summarize and compare these errors we
calculate the root of the mean squared error (RMSE) given by:

$$
\operatorname{RMSE}=\sqrt{\frac{\sum_{i=1}^{n}(\hat\theta_i-\theta_i )^2}{n}}
$$

where $\hat\theta_i$ are the predictions derived from the respective
MLCT derivations and $\theta_i$ are the observations taken from the
Agland2000 data set.


@
<<rmse>>=


rmseDf <- ldply( list("nomos05", "nomos1"),
                function( brickName) {
                  rmseRast( getPeelBand( get( brickName), "crop"),
                           unstack( agland)[[1]])
                })
rmseDf <- cbind( c( 0.5, 1.0), rmseDf)
colnames( rmseDf) <- c( "$A_{min}$", "RMSE")

cropScatDf <- 
  data.frame( as( stack( getPeelBand( nomos05, "crop"),
                        getPeelBand( nomos1, "crop"),
                        unstack( agland)[[1]],
                        raster::mask(acres, cusaMask)),
                 "SpatialGridDataFrame"))
colnames(cropScatDf) <-
  c( "nomos05", "nomos1", "agland", "acres", "lon", "lat")
cropScatDf$weight <- with( cropScatDf, acres/ max(acres))


if( overwriteFigures) scatPlot1 <-
  ggplot( data=
         cropScatDf, ##[ sample( 1:nrow(cropScatDf),
                     ##       round( nrow(cropScatDf) *0.05)),],
         aes( agland, nomos1,
             size= weight)) +
  geom_point( alpha= 0.03) +
  scale_area( limits= c(0.7, 1),
             breaks= seq( 0.7, by= 0.1),
             to= c(0.7, 1) *6) +
  geom_abline( size= 2,
              alpha= 0.4) +
  theme_bw() +
  scale_x_continuous( "Agland2000",
                     limits= c( 0, 1),
                     expand= c( 0.025, 0)) +
  scale_y_continuous( "MLCT, A_min = 1.0",
                     limits= c( 0, 1),
                     expand= c( 0.025, 0)) +
  coord_equal() +
  opts( legend.position= "none")


@

\begin{figure}[hpt]
  \begin{center} 

<<fig_scatplot1>>= 

if( overwriteFigures) {
  setwd( texWd)
  my.ggsave( "fig_scatPlot1.png",
         plot= scatPlot1)
}

@ 

\includegraphics{fig_scatPlot1}
  \end{center} 
  \caption{Scatter plot of MLCT crop ($A_{min}=1.0$, no mosaic) versus Agland2000 cropland}
  \label{fig:scatplot1} 
\end{figure} 

\begin{figure}[hpt]
  \begin{center} 


<<fig_scatplot05>>= 

if( overwriteFigures) {
  setwd( texWd)
  my.ggsave( "fig_scatPlot05.png",
         plot= scatPlot1 +
         aes(agland, nomos05, size=weight) +
         scale_y_continuous( "MLCT, A_min = 0.5",
                            limits= c( 0, 1),
                            expand= c( 0.025, 0)))
}



@ 

\includegraphics{fig_scatPlot05}
  \end{center} 
  \caption{Scatter plot of MLCT crop ($A_{min}=0.5$, no mosaic) versus Agland2000 cropland}
  \label{fig:scatplot05} 
\end{figure} 

@ 
<<table_rmse, results=tex, eval=TRUE>>=

print( xtable( rmseDf,
              caption= "RMSE, MLCT vs. Agland2000 crop",
              label= "tab:rmse",
              digits= c( 0, 1, 3)),
      include.rownames= FALSE,
      sanitize.colnames.function= function(x) x)

@ %def 

The results on Table \ref{tab:rmse} indicate that $A_{min}=0.5$ is
more representative of the distribution of cropland because although
the total area indicated is higher there is less error on a
cell-by-cell basis indicating that it does a better job of
representing the spatial distribution than $A_{min}=1.0$.  Later when
we recalculate the cell proportions by accepting the values for
cropland area from Agland2000 as truth we can expect minimal
distortion in reconciling its landscape with that given by MLCT.  From
this point forward we will consider only the statistics derived from
setting $A_{min}=0.5$ for the aggregation of the MLCT data due to this
improved fit with Agland2000 cropland and its full consideration of
all information imparted by the MLCT data.


\section{NLCD Offsets}
\label{sec:nlcd_offsets}


From Table \ref{tab:areas} it is apparent that the MLCT results are
negatively biased in the areas assigned to water, wetland, and urban
features relative to the NLCD.  It is clear from visual inspection
that features of these classes tend to have smaller characteristic
dimensions which causes them to be overlooked in the the MLCT data due
to its resolution.  The most obvious example are the rural
transportation networks in areas delineated by the Public Land Survey
System (PLSS) where roads have been laid out on a generally regular
grid of square miles.  In the PEEL classification this infrastructure
is included in the urban class as another form of developed land.  It
is important to represent wetlands and water features in our input to
the PEEL model because these areas have high likliehoods of being set
aside for conservation purposes, which would be represented as a
constraint on land conversion in the model.

To merge this information from the NLCD we begin by simply accepting
the areas for water, wetland, and urban classes in the reclassified,
5$'$-aggregated version of NLCD that we have computed as truth and
calculate offsets for those classes versus our 5$'$ MLCT data by
straight subtraction.  The other classes are then adjusted so that
they are present in proportion to each other as indicated by MLCT but
in the area remaining after accepting the water, wetland, and urban
areas from NLCD.  The additive offsets needed to achieve this balance
and account for the entire area of the cell are calculated so that the
effects of this process on all classes may be considered on a common
basis.

@
<<offsets_calc>>=

nlcdKeep <- stack( llply( names( peelClasses), function( class) {
  if( class %in% c( "water", "wetland", "urban"))
    ones else zeroes
}))

nlcdIgnore <- stack( llply( names( peelClasses), function( class) {
  if( class %in% c( "water", "wetland", "urban"))
    zeroes else ones
}))

nlcdKeepOffsets <-
  (nlcd -agg05) *nlcdKeep

mlctKeep <- agg05 *nlcdIgnore

## nlcdIgnoreOffsets <-
##   -1 *mlctKeep /sum( mlctKeep) *sum( nlcdKeepOffsets)

nlcdIgnoreOffsets <-
  overlay( mlctKeep, sum( mlctKeep), sum( nlcdKeepOffsets),
          fun= function( mk, smk, snko) {
            ifelse( mk == 0 & smk ==0,
                   0,
                   -1 *mk /smk *snko)
          })


nlcdOffsets <- nlcdKeepOffsets +nlcdIgnoreOffsets

nlcdOffsets <- 
  writeRaster( nlcdOffsets,
              filename= paste( rasterWd, "nlcdOffsets.tif", sep= "/"),
              overwrite= TRUE)


nlcdOffsets <- stack( nlcdOffsets, sum( nlcdOffsets))
layerNames( nlcdOffsets) <- c( names( peelClasses), "total")

thumbNlcdOffsets <- crop( nlcdOffsets, thumbExtent)

## offsetsMap <- coverMaps( nlcdOffsets, 0.4) +
##   coord_equal() +
##   facet_grid( variable ~ .) +
##   scale_fill_gradientn( "diff", colours= rev( brewer.pal( 11, "BrBG")), 
##                        limits= c( 0.1, -0.1),
##                        breaks= seq( 0.1, -0.1, by= -0.02))

offsetsMap1 <- coverDiffMaps( nlcdOffsets, samp= 0.4,
                             classes= layerNames( nlcdOffsets)[ 1:5])

offsetsMap2 <- coverDiffMaps( nlcdOffsets, samp= 0.4,
                             classes= layerNames( nlcdOffsets)[ 6:10])


thumbOffsetsMap <-
  coverDiffMaps( thumbNlcdOffsets,
                classes= layerNames( thumbNlcdOffsets)[-10]) +
  facet_wrap( ~variable)


## offsetsMap$data <-
##   within( offsetsMap$data,
##          cuts <- cut( value, breaks=
##                      c( -1, -0.5, -0.1, -0.05, -0.01,
##                        0.01, 0.05, 0.1, 0.5, 1)))


## ggplot( offsetsMap$data, aes( x= s1, y=s2, fill=cuts)) +
##   geom_tile() +
##   scale_fill_manual( values= brewer.pal( 9, "BrBG")) +
##   facet_grid( variable ~ .) +
##   coord_equal()

## thumbOffsetsMap <- coverMaps( crop( nlcdOffsets, thumbExtent)) +
##   coord_equal() +
##   ##facet_grid( variable ~ .) +
##   scale_fill_gradientn( "diff", colours= rev( brewer.pal( 11, "BrBG")), 
##                        limits= c( 1.0, -1.0),
##                        breaks= seq( 0.5, -0.5, by= -0.1))

## thumbOffsetsMap$data <-
##   within( thumbOffsetsMap$data,
##          cuts <- cut( value, breaks=
##                      c( -1, -0.5, -0.1, -0.05, -0.01,
##                        0.01, 0.05, 0.1, 0.5, 1)))

## ##breaks= c( -1, seq( -0.5, 0.5, by=0.1)[-6], 1)

## ggplot( thumbOffsetsMap$data, aes( x= s1, y=s2, fill=cuts)) +geom_tile() +scale_fill_manual( values= brewer.pal( 9, "BrBG")) +facet_wrap(~ variable)

## thumbOffsetsMap+ geom_tile( aes( x= s1, y=s2, fill=cuts)) +scale_fill_manual( values= brewer.pal( 9, "BrBG"))


@ 

\begin{figure}[hpt]
  \begin{center} 

@ 
<<fig_offsetsmap1>>=

if( overwriteFigures) {
  setwd( texWd)
  my.ggsave( "fig_offsets1.png", plot= offsetsMap1, height= 7)
}

@ %def 

\includegraphics{fig_offsets1}
  \end{center} 
  \caption{NLCD offsets}
  \label{fig:offsets1} 
\end{figure} 

\begin{figure}[hpt]
  \begin{center} 

@ 
<<fig_offsetsmap2>>=

if( overwriteFigures) {
  setwd( texWd)
  my.ggsave( "fig_offsets2.png", plot= offsetsMap2, height= 7)
}

@ %def 

\includegraphics{fig_offsets2}
  \end{center} 
  \caption{NLCD offsets (cont.)}
  \label{fig:offsets2} 
\end{figure} 


\autoref{fig:offsets1} and \autoref{fig:offsets2} show the spatial distributions of the offsets calculated based on our assumptions about the water, wetland, and urban classes in the NLCD.


@ 
<<cor_offsets>>=

corOffsets <- cor( data.frame(as( nlcdOffsets, "SpatialGridDataFrame"))[, 1:9],
                  use= "complete.obs")
colnames( corOffsets) <- names( peelClasses)
rownames( corOffsets) <- names( peelClasses)

ord <- order.dendrogram( as.dendrogram( hclust( dist( corOffsets))))

corOffsetsPlot <- 
  ggplot( melt( corOffsets),
         aes( x=X1, y=X2, fill= value)) +
  geom_tile() +
  theme_bw() +
  opts( panel.grid.minor= theme_blank(),
       panel.grid.major= theme_blank(),
       panel.background= theme_blank(),
       axis.title.x= theme_blank(),
       axis.text.x= theme_text( angle= 90, hjust=1),
       axis.title.y= theme_blank()) +
  scale_x_discrete( limits= colnames( corOffsets)) +
  scale_y_discrete( limits= colnames( corOffsets)) +
  scale_fill_gradientn( "", colours= rev( brewer.pal( 11, "BrBG")), 
                       limits= c( 1.0, -1.0),
                       breaks= seq( 1.0, -1.0, by= -0.2))

if( overwriteFigures) {
  oldWd <- setwd( texWd)
  ggsave( "fig_corOffsets.pdf", plot= corOffsetsPlot)
  setwd( oldWd)
}



@ %def 


\begin{figure}[hpt]
  \begin{center} 
    \includegraphics{fig_corOffsets}
  \end{center} 
  \caption{Covariance matrix of NLCD offsets}
  \label{fig:corOffsets} 
\end{figure} 

The resulting offsets are added to the aggregated fractions calculated
from the MLCT with $A_{min}=0.5$.  


<<cusa_offset>>=

setwd( rasterWd)

nlcdOffsets <- brick( "nlcdOffsets.tif")
layerNames( nlcdOffsets) <- names( peelClasses)

mlctAdj <- list( Amin=0.5)
mlctAdj$agg <-
  if( overwriteRasters) {
    overlay( agg05, nlcdOffsets,
            fun= sum,
            filename= "agg05Adj.tif",
            overwrite= TRUE)
  } else brick( list.files( rasterWd,
                           patt= "agg05Adj.tif",
                           full.names= TRUE))

layerNames( mlctAdj$agg) <- names( peelClasses)

mlctAdj  <- decomposeMosaic( mlctAdj, overwrite= overwriteRasters, progress= "text")

@ 





<<areas2>>=

# reuse area table code from above; better to implement a function?

rasterNames2 <- c( "agland", "nlcd", "agg05", "nomos05",
                  "nlcdOffsets", "mlctAdj$agg", "mlctAdj$nomos")

dataSets2 <- sapply( rasterNames2,
  function( n) eval( parse( text=n)))

areas2 <- llply( dataSets2,
  function( d) {
    res <- cellStats( d *acres, sum)
    names( res) <- layerNames( d)
    res
  })

areasDf2 <- ldply( areas2, function( a) {
  melt( t( as.data.frame( a)))
})
areasDf2 <-
  areasDf2[, c( 1, 3, 4)]
colnames( areasDf2) <-
  c( "map", "class", "acres")

areasDf2 <-
  transform( areasDf2,
            class= factor( class,
              levels= c("crop", "open",
                names( peelClasses)[-c(4,6,8)],
                "mosaic", "total")),
            map= factor( map,
              levels= rasterNames2))

## areasDf2$map <-
##   factor( areasDf2$map,
##          levels= rasterNames2)

## unused
## areasPlot2 <-
##   qplot( map, acres /10^6,
##         data= subset(areasDf2,
##           class != "total" & map != "offset"),
##         geom="bar", position= "stack",
##         fill= class,
##         stat="summary", fun.y="sum") +
##   scale_fill_manual( "",
##                     values= peelLegend, 
##                     breaks= names( peelClasses)) +
##   scale_y_continuous( "Ma",
##       limits= c(0,2000)) +
##   theme_bw()



## covers in rows

##areasCt2 <- cast( areasDf2, X2 ~ .id, subset= X2 != "total", sum, margins="grand_row")

areasCt2 <- cast( areasDf2,
                 class ~ map,
                 subset= class != "total",
                 value= "acres",
                 sum,
                 margins="grand_row")

rownames( areasCt2) <- areasCt2[, "class"]
areasCt2 <- areasCt2[, -1]
areasCt2 <- areasCt2[ c( names( peelClasses), "(all)"), rasterNames2]

@ 

Following these algebraic acrobatics it seems prudent to check our
accounting with some simple arithmetic.  Working backwards from the
final result of adding NLCD-derived offsets to the raster stack
derived from the MLCT with $A_{min}=0.5$ and decomposing the remaining
mosaic fractions into their constituent cover types, subtracting the
deltas that came from the mosaic decomposition, subtracting offsets
calculated from the NLCD, and subtracting the aggregated MLCT data
from the previous chapter 
\todo{hyperlink to section where MLCT was aggregated} 
should produce zeroes everywhere, plus or minus the noise of floating
point math.


<<restack_check>>=

## check that everything balances
## output of decomposeMosaic is not brick()ed properly
## in the sense that the layer set is incomplete
## and out of order
  

restack <- function( peelBrick) {
  u <- unstack( peelBrick)
  names( u) <- layerNames( peelBrick)
  r <- do.call( stack,
          llply( names( peelClasses),
                function( cover) {
                  if( is.null( u[[ cover]]))
                    zeroes
                  else
                    u[[ cover]]
                }))
  layerNames( r) <- names( peelClasses)
  r
}
                                        # restack() takes any of the bricks/stacks from
                                        # previous functions and rearranges the layers
                                        # to match the PEEL classes, inserting layers of
                                        # zeroes as needed


## check <- llply( mlctAdj[ c("nomos", "delta", "agg")], restack)
## names(check) <- NULL
## do.call( overlay, c(check , fun=function( n, d, a) n-d-a))

restackOverlay <- function( rasterList, fun) {
  l <- llply( rasterList, restack)
  names( l) <- NULL
  do.call( overlay, c( l, fun=fun))
}
                                        # restackOverlay() runs its arguments through restack()
                                        # and applies a function to its outputs

## restackOverlay( mlctAdj[ c("nomos", "delta", "agg")],
##                function( n, d, a) n-d-a)

## restackOverlay( list( mlctAdj$agg, offset, agg05),
##                function( a2, o, a) a2-o-a)

@ 


<<results_restack_check, results=verbatim>>=

check <- restackOverlay( c( mlctAdj[ c("nomos", "delta")], nlcdOffsets, agg05),
               function( n, d, o, a) n-d-o-a)
layerNames(check) <- names( peelClasses)

check

@ %def 

@ 
<<table_restack_check, results=tex, eval=TRUE>>=
  
checkTable <-
  xtable( cbind( class=peelClasses,
                min=minValue( check),
                max=maxValue(check)),
         caption= "Balance of adjustment fractions and original MLCT aggregation", 
         label= "tab:restack_check")
digits( checkTable) <- c( 0, 0,-2,-2)
print( checkTable)
  
@ %def 

To assess whether the process of adding in the NLCD offsets has
improved overall cropland accuracy we can perform the same error
calculation from above and extend Table~\ref{tab:rmse} with the new
result, giving us Table~\ref{tab:rmse2}.

@ 
<<table_rmse2, results=tex, eval=TRUE>>=

                                        # add the RMSE for the new crop map
                                        # and an indication of the NLCD offsets' presence
  
rmseDf2 <-
  cbind( offset=c( TRUE, FALSE, FALSE),
        rbind( c( 0.5,
                 rmseRast( getPeelBand( mlctAdj$nomos, "crop"),
                          unstack( agland)[[ 1]])),
              rmseDf))

                                        # add the RMSE for the open class
rmseDf2 <-
  cbind( rmseDf2,
        rmseOpen=ldply( list(mlctAdj$nomos, nomos05, nomos1),
                function( brickVar) {
                  rmseRast( getPeelBand( brickVar, "open"),
                           unstack( agland)[[ 2]])
                }))
colnames(rmseDf2)[ c(3,4)] <- c( "$RMSE_{crop}$", "$RMSE_{open}$")

           
print( xtable( rmseDf2,
              caption= "RMSE, MLCT vs. Agland2000 crop with NLCD offsets",
              label= "tab:rmse2",
              digits= c( 0, 0, 1, 3, 3)),
      include.rownames= FALSE,
      sanitize.colnames.function= function(x) x)

@ %def 

\todo[caption=Should the RMSE tables be rearranged?]{Would it make
  more sense to have the row order and independent variables (first
  three) reversed in Table \ref{tab:rmse} and \ref{tab:rmse2}?}

Seeing that this modifcation to the data set has improved our overall
accuracy of the distribution of croplands the next step is to examine
the total areas for all classes compared with the input data sets.  


<<tab_areas2, results=tex, eval=TRUE>>=


local({
  colnames( areasCt2) <- c( "Agland2000", "NLCD", "MLCT", 
                           "\\pbox[c][][c]{3in}{MLCT\\\\No Mosaic}",
                           "\\pbox[c][][c]{3in}{NLCD\\\\Offsets}", 
                           "\\pbox[c][][c]{3in}{MLCT\\\\Adjusted}",
                           "\\pbox[c][][c]{3in}{\\smallskip{}MLCT\\\\Adjusted\\\\No Mosaic}")
  print( xtable( areasCt2 / 10^6, 
                caption= "Effect of NLCD offsets on total acreages, $A_{min}=0.5$",
                label= "tab:areas2",
                digits= 1),
        size= "small",
        add.to.row= list( 
          pos= list( 0, nrow( areasCt)),
          command= rep("\\noalign{\\smallskip}", times= 2)),        
        sanitize.colnames.function= function(x) x)
        ##,
        ##        sanitize.text.function= function(x) x))
  ##,
  ##      floating= FALSE)
})

if( overwriteFigures) areasPlotAdj <-
  qplot( map, acres /10^6,
        data= subset( areasDf2,
          class != "total" & map != "nlcdOffsets"),
        geom="bar", position= "stack",
        fill= class,
        stat="summary", fun.y="sum") +
  scale_fill_manual( "",
                    values= peelLegend[ levels( areasDf2$class)[1:9]], #peelLegend, 
                    breaks= names( peelClasses)) +
  scale_y_continuous( "Ma",
      limits= c(0,2000)) +
  theme_bw() +
  scale_x_discrete( "",
      limits= rasterNames2[ rasterNames2 != "nlcdOffsets"],
      breaks= rasterNames2[ rasterNames2 != "nlcdOffsets"],
      labels= expression("Agland2000", "NLCD",
          atop( atop( textstyle( "MLCT"),
                     textstyle( A[ min] ==0.5)),
               phantom(0)),
          atop( atop( textstyle( "MLCT"),
                     textstyle( A[ min] ==0.5)),
               "No Mosaic"),
          atop( atop( textstyle( "MLCT"),
                     textstyle( A[ min] ==0.5)),
               "Adjusted"),
          atop( atop( textstyle( "MLCT"),
                     textstyle( A[ min] ==0.5)),
               scriptstyle( "Adjusted, No Mosaic"))))

      ## labels= c("Agland", "NLCD",
      ##   "MLCT\nA_min=0.5", "MLCT\nA_min=0.5\nNo Mosaic",
      ##   "MLCT\nAdjusted", "MLCT\nAdjusted\nNo Mosaic"))



cropScatAdjDf <- 
  data.frame( as( stack(getPeelBand( mlctAdj$nomos, "crop"),
                        unstack( agland)[[1]],
                        raster::mask(acres, cusaMask)),
                 "SpatialGridDataFrame"))
colnames(cropScatAdjDf) <-
  c( "mlctAdj", "agland", "acres", "lon", "lat")
cropScatAdjDf$weight <- with( cropScatAdjDf, acres/ max(acres))


if( overwriteFigures) scatPlotAdj <-
  ggplot( data=
         cropScatAdjDf, ##[ sample( 1:nrow(cropScatAdjDf),
                       ##         round( nrow(cropScatAdjDf) *0.05)),],
         aes( agland, mlctAdj,
             size= weight)) +
  geom_point( alpha= 0.03) +
  scale_area( limits= c(0.7, 1),
             breaks= seq( 0.7, by= 0.1),
             to= c(0.7, 1) *6) +
  geom_abline( size= 2,
              alpha= 0.4) +
  ##  stat_smooth( method= "lm",
  ##              se= FALSE,
  ##              size= 3,
  ##              alpha= 0.2) +
  theme_bw() +
  scale_x_continuous( "Agland2000",
                     limits= c( 0,1),
                     expand= c( 0.025,0)) +
  scale_y_continuous( "MLCT Adjusted",
                     limits= c( 0,1),
                     expand= c( 0.025,0)) +
  coord_equal() +
  opts( legend.position= "none")



@

\begin{figure}[hpt]
  \centering

 
<<fig_offsets>>=
 
if( overwriteFigures) {
  offsetsPlot <-
    qplot( class, acres /10^6, 
        data= subset( areasDf2,
          map == "nlcdOffsets" & class != "total"),
        geom= "bar",
        fill= class) +
    scale_fill_manual( "",
        values= peelLegend, 
        breaks= names( peelLegend)) +
    scale_y_continuous( "Ma", limits=c( -50, 80)) +
    scale_x_discrete( "", breaks= c( names( peelClasses), "total")) +
    coord_flip() +
    theme_bw() +
    opts( legend.position= "none")
  setwd( texWd)
  ggsave( "fig_offsets.pdf",
         plot= offsetsPlot)
}



@ %def 

  \includegraphics{fig_offsets}
  \caption{Total offsets calculated from NLCD}
  \label{fig:offsets}
\end{figure}


\begin{figure}[hpt]
  \centering


@ 
<<fig_areasAdj>>=

if( overwriteFigures) {
  setwd( texWd)
  ggsave( "fig_areasAdj.pdf", plot= areasPlotAdj)
}

@ %def
  \includegraphics{fig_areasAdj}
  \caption{Area totals after NLCD adjustment}
  \label{fig:areasAdj}
\end{figure}

\begin{figure}[hpt] 
  \begin{center} 

<<fig_scatPlotAdj>>= 

if( overwriteFigures) {
  setwd( texWd)
  my.ggsave( "fig_scatPlotAdj.png",
         plot= scatPlotAdj)
}


  
@ 

    \includegraphics{fig_scatPlotAdj}
  \end{center} 
  \caption{Scatter plot of MLCT adjusted crop versus Agland2000 cropland}
  \label{fig:scatPlotAdj} 
\end{figure} 




<<agc>>=

## thumbAgland <- crop( agland,
##                     extent(-83.5, -(82+25/60), 42+55/60, 44+5/60),
##                     filename= "thumbAgland.tif",
##                     progress="text")

nomosCrop <- getPeelBand( mlctAdj$nomos, "crop")
aglandCrop <- unstack( agland)[[ 1]]

## nomosTruth is the sum of the classes from the NLCD offsets.
## other classes adjusted from now on cannot exceed $1 - nomosTruth

if( overwriteRasters) {
  ## nomosTruth <- getPeelBand( mlctAdj$nomos, "water") +
  ##   getPeelBand( mlctAdj$nomos, "wetland") +
  ##     getPeelBand( mlctAdj$nomos, "urban")
  ## nomosTruth <- writeRaster( nomosTruth, "nomosTruth.tif")
  nomosTruth <- overlay( getPeelBand( mlctAdj$nomos, "water"),
                        getPeelBand( mlctAdj$nomos, "wetland"),
                        getPeelBand( mlctAdj$nomos, "urban"),
                        fun= sum,
                        filename= "nomosTruth.tif",
                        overwrite= TRUE)
} else nomosTruth <-
  raster( list.files( dataPath,
                    patt="nomosTruth.tif",
                    full.names= TRUE)) 


nomosClasses <- layerNames( mlctAdj$nomos)[ -9]
                                        # leaves out 'total'
                                        # mosaic is already gone

## This is the overlay() bug.  These values of peelCrop should be the same
## but they're not.

## peelCrop <-
##   overlay( aglandCrop, nomosCrop, nomosTruth, fun=
##           function( a, n, t) {
##             ifelse( is.na( a), n, min( a, 1 -t))
##           },
##           filename= "peelCrop.tif",
##           overwrite= TRUE)

peelCrop <-
  if( overwriteRasters) {
    calc( stack( aglandCrop, nomosCrop, nomosTruth), fun=
         function( st) {
           a <- st[ 1]
           n <- st[ 2]
           t <- st[ 3]
           ifelse( is.na( a), n, min( a, 1 -t))
         },
         filename= "peelCrop.tif",
         overwrite= TRUE)
  } else raster( "peelCrop.tif")


offsetStack <-
  stack( llply( nomosClasses,
               function( class) {
                 if( class =="crop")
                   peelCrop
                 else
                   zeroes
               }))


## noncropFactor <-
##   overlay( peelCrop, nomosCrop, nomosTruth, fun=
##           function( p, n, t) {
##             ifelse( 1 - n - t <= 0,
##                    0,
##                    1 +( n -p) /( 1 -n -t))
##           })

noncropFactor <-
  overlay( peelCrop, nomosCrop, nomosTruth, fun=
          function( p, n, t) {
            ifelse( 1 -n -t <= 0,
                   0,
                   ( 1 -p -t) /( 1 -n -t))
          })


factorStack <- 
  stack( llply( nomosClasses,
               function( class) {
                 if( class == "crop")
                   zeroes
                 else if( class %in%
                         c( "water", "wetland", "urban"))
                   ones
                 else
                   noncropFactor
               }))

## stupid overlay bug!
##
## aglandComplete <-
##   if( overwriteRasters || TRUE) {
##     overlay( stack( unstack( mlctAdj$nomos)[ -9]),
##             factorStack,
##             offsetStack,
##             fun= function( x, m, b) m *x +b,
##             filename= "aglandComplete.tif",
##             overwrite= TRUE,
##             progress= "text")
##   } else brick( list.files( rasterWd,
##                          patt="^aglandComplete.tif$",
##                          full.names=TRUE))
## layerNames( aglandComplete) <- names(peelClasses)[-8]

aglandComplete <-
  stack( unstack( mlctAdj$nomos)[ -9]) *factorStack +offsetStack
aglandComplete <- writeRaster( aglandComplete,
                              "aglandComplete.tif",
                              overwrite= TRUE)
layerNames( aglandComplete) <- names(peelClasses)[-8]

aglandCompleteSum <- sum( aglandComplete)

## lt1AgcTotal <- extract( stack( peelCrop,
##                                nomosCrop,
##                                nomosTruth,
##                                noncropFactor,
##                                aglandComplete,
##                                aglandCompleteSum),
##                        which( aglandCompleteSum[] < 0.999))

## colnames( lt1AgcTotal)[ 1:4] <- c( "p", "n", "t", "factor")
## lt1AgcTotal <- data.frame( lt1AgcTotal)
## lt1AgcTotal <- within( lt1AgcTotal, { term1 <- n-p; term2 <- 1-n-t})

## within( head( lt1AgcShrub), { 


## normalize to fix 65 pixels missing area
aglandComplete <- aglandComplete /aglandCompleteSum
layerNames( aglandComplete) <- names(peelClasses)[-8]

agcMap <- coverMaps( aglandComplete, 0.4) +
  coord_equal() +
  facet_grid( variable ~ .)


@ 

\begin{figure}[hpt] 
\begin{center} 

<<fig_agc>>= 

setwd( texWd)
my.ggsave( "fig_agc.png", width=4.5, height=8)

## png( file="fig_agc.png",
##     height= 8, width= 4.5, units= "in"  # no effect
##     res= 300)
## print( agcMap)
## dev.off()

@ 

\includegraphics{fig_agc}
\end{center} 
\caption{Agland Complete cover maps} 
\label{fig:agc} 
\end{figure} 


@

blah blah blah

@ 
<<table_rmse3, results=tex, eval=TRUE>>=

setwd( rasterWd)  

rmseDf3 <- 
  cbind( agland=c( TRUE, rep(FALSE, times=3)),
        rbind( c( TRUE, 0.5,
                 rmseRast( getPeelBand( aglandComplete, "crop"),
                          unstack( agland)[[ 1]]),
                 rmseRast( getPeelBand( aglandComplete, "open"),
                          unstack( agland)[[ 2]])),
              rmseDf2))
rmseDf3 <- within(rmseDf3, offset <- as.logical( offset))
                                        # had to change offset column back
                                        # to true/false;  maybe this can be
                                        # avoided with list() instead of c()

rmseXt <- xtable( rmseDf3,
                 caption= "RMSE of Agland Complete vs. Agland2000",
                 label= "tab:rmse3",
                 digits= c( 0, 0, 0, 1, 3, 3))
                                        # looks like some kind of bug in xtable()
                                        # manual correction:
rmseXt$agland <- rmseDf3$agland
rmseXt$offset <- rmseDf3$offset

print( rmseXt,
      include.rownames= FALSE,
      sanitize.colnames.function= function(x) x)

@ %def 

\begin{figure}[hpt] 
  \begin{center} 

<<fig_scatPlotAgc>>= 

if( overwriteFigures) {
  setwd( texWd)
  my.ggsave( "fig_scatPlotAgc.png",
         plot= scatPlotAgc)
}


  
@ 

    \includegraphics{fig_scatPlotAgc}
  \end{center} 
  \caption{Scatter plot of MLCT adjusted crop versus Agland2000 cropland}
  \label{fig:scatPlotAgc} 
\end{figure} 

<<tab_areas3, results=tex, eval=TRUE>>=

areasCt3 <- acreageTable( c( rasterNames2[ c( 1, 2, 4, 7)], "aglandComplete"))

local({
  colnames( areasCt3) <-
    c( "Agland2000", "NLCD",
      "\\pbox[c][][c]{3in}{MLCT\\\\No Mosaic}",
      "\\pbox[c][][c]{3in}{\\smallskip{}MLCT\\\\Adjusted\\\\No Mosaic}",
      "AgC")
  print( xtable( areasCt3 / 10^6, 
                caption= "Agland Complete (AgC) acreages, $A_{min}=0.5$",
                label= "tab:areas3",
                digits= 1),
        size= "small",
        add.to.row= list( 
          pos= list( 0, nrow( areasCt)),
          command= rep("\\noalign{\\smallskip}", times= 2)),        
        sanitize.colnames.function= function(x) x)
  ##,
  ##      floating= FALSE)
})

cropScatAgcDf <- 
  data.frame( as( stack(getPeelBand( aglandComplete, "crop"),
                        aglandCrop,
                        raster::mask(acres, cusaMask)),
                 "SpatialGridDataFrame"))
colnames(cropScatAgcDf) <-
  c( "agc", "agland", "acres", "lon", "lat")
cropScatAgcDf$weight <- with( cropScatAgcDf, acres/ max(acres))


if( overwriteFigures) scatPlotAgc <-
  ggplot( data=
         cropScatAgcDf, ##[ sample( 1:nrow(cropScatAgcDf),
                       ##         round( nrow(cropScatAgcDf) *0.05)),],
         aes( agland, agc,
             size= weight)) +
  geom_point( alpha= 0.03) +
  scale_area( limits= c(0.7, 1),
             breaks= seq( 0.7, by= 0.1),
             to= c(0.7, 1) *6) +
  geom_abline( size= 2,
              alpha= 0.4) +
  theme_bw() +
  scale_x_continuous( "Agland2000",
                     limits= c( 0, 1),
                     expand= c( 0.025, 0)) +
  scale_y_continuous( "Agland Complete",
                     limits= c( 0, 1),
                     expand= c( 0.025, 0)) +
  coord_equal() +
  opts( legend.position= "none")


cropScatAgcDf <-
  within( cropScatAgcDf,
         { cat <- NA
           cat[    agc == 0] <- 0
           cat[ agc > 0 & is.na( agland)] <- 1
           cat[ agc > 0 & agc == agland] <- 2
           cat[ agc > 0 & agc  < agland] <- 3
           cat[ agland == 1] <- 4
         })

agcThemeMap <-
  ggplot( cropScatAgcDf[ !is.na( cropScatAgcDf$cat),],
         aes( x= lon, y= lat)) +
  geom_tile( aes( fill= factor( cat))) +
  scale_fill_brewer( "",
                    breaks= 0:4,
                    labels= c(
                      "AgC = 0",
                      "AgC > 0 and Ag2k is null",
                      "AgC > 0 and AgC = Ag2k",
                      "Agc > 0 and AgC < Ag2k",
                      "Ag2k = 1")) +
  coord_equal()


@


\begin{figure}[hpt] 
  \begin{center} 

<<fig_agcThemeMap>>= 

if( overwriteFigures) {
  setwd( texWd)
  my.ggsave( "fig_agcThemeMap.png",
         plot= agcThemeMap)
}

@ 

    \includegraphics{fig_agcThemeMap}
  \end{center} 
  \caption{Thematic map of conflicts between NLCD offsets and Agland2000}
  \label{fig:agcThemeMap} 
\end{figure} 


<<crop_cats>>=

setwd( rasterWd)
##cropCats <- rep( NA, times=10)
cropCats <-
  c("cereals", "field_crop", "forage", "maize",
    "rice", "shrub_crop", "soybean", "sugarcane",
    "tree_crop", "wheat")
names( cropCats) <- cropCats


cropCatsPeel <-
  list( crop= c( "cereals", "field_crop",
                "maize", "rice", "soybean",
                "sugarcane", "wheat"),
       open= "forage",
       shrub= "shrub_crop",
       forest= "tree_crop")
                     
cropCats <- llply(  cropCats, function(c) {
  raster( paste( dataPath,
                paste( c, "tif", sep="."),
                sep= "/"))
})

cropStack <- stack( cropCats)


cropSum <- overlay( stack( cropCats[ cropCatsPeel$crop]),
                   fun= sum)

cropSum[ is.na( cropSum[])
        & !is.na( getPeelBand( aglandComplete,
                              "crop")[])
        ] <- 0
cropSum <- writeRaster( cropSum,
                   file= "cropSum.tif",
                   overwrite= TRUE)

cropNormalFunc <- function( st) {
  cropCat <- st[ 1]
  cropSum <- st[ 2]
  agc <-     st[ 3]
  ifelse( cropSum == 0,
         0,
         cropCat / cropSum)
}

cropNormal <- stack( llply( cropCats[ cropCatsPeel$crop],
                           function( crop) {
                             calc( stack( crop,
                                         cropSum,
                                         getPeelBand( aglandComplete, "crop")),
                                  fun= cropNormalFunc)
                           }))

cropSubClasses <- getPeelBand( aglandComplete, "crop") *cropNormal
layerNames( cropSubClasses) <- cropCatsPeel$crop


@ 



\begin{figure}[hpt] 
  \begin{center} 

<<fig_cropSubClassesMap>>= 

if( overwriteFigures) {
  cropSubClassesMap <-
    coverMaps( cropSubClasses, 0.4) +
    coord_equal() +
    facet_grid( variable ~ .)
  my.ggsave( paste( texWd,
                   "fig_cropSubClassesMap.png",
                   sep= "/"),
            plot= cropSubClassesMap)
}

@ 
    \includegraphics{fig_cropSubClassesMap}
  \end{center} 
  \caption{Normalized fractions for crop sub-classes}
  \label{fig:cropSubClassesMap} 
\end{figure} 


We could assume that forage crops come from open class but we don't
know enough about the confusion between Aglands2000 pasture and the
open class in the first place.  The focus here is field crops so that
is the only class that we are attempting to disaggregate for now.
Tree and shrub crops could be taken from the corresponding cover
types, but assuming that they are caught up in that classification is
a blind leap and their areas are small.  On the other hand, their
economic impact may be disproportionate to their areas by virute of
price, but this will have to be studied more carefully.

Double-cropping is ignored for now by normalizing the crop fractions
by the sum of all crops, which can exceed unity in instances of
intense double-cropping.  The predominant double-cropping system in
the cUSA to our knowledge is soy followed by winter wheat, but there
may be others.  In areas where soy and wheat are double-cropped their
areas will be underestimated in this data set relative to that given
in the 175Crops2000 data set, subsequent to the NLCD offset
adjustment.  This issues also bears further study.

@ 
<<restack_crops>>=


check <- 
  getPeelBand( aglandComplete, "crop") -
  sum( cropSubClasses)

##  overlay( cropSubClasses, fun=sum)



## otherCrops <-
##   calc( stack( getPeelBand( aglandComplete, "crop"),
## 	      cropSum),
##         fun= function( st) {
##           agc <- st[ 1]
##           ag <- st[ 2]
##           ifelse( is.na( ag), agc, 0)
##         })

otherCrops <-
  overlay( getPeelBand( aglandComplete, "crop"),
	  cropSum,
        fun= function( agc, ag) {
          ifelse( is.na( ag), agc, 0)
        })

check <- 
  getPeelBand( aglandComplete, "crop") -
  sum( cropSubClasses) -
  otherCrops


peelData <- stack( aglandComplete, cropSubClasses, otherCrops, check)
layerNames( peelData)[ 16:17] <- c("other_crop", "check")

peelDf <- data.frame(peelData[])

noisyCells <- rownames( with( peelDf,
    peelDf[ !is.na( check) & check >= 0.001,]))
# 325 cells with noise above this threshold


otherCrops <- otherCrops + check

peelData <- stack( aglandComplete, cropSubClasses, otherCrops)
layerNames( peelData)[ 16] <- c("mlct_crop")

peelDf <- data.frame( peelData[ !is.na( grid[])])
rownames( peelDf) <- grid[][ !is.na(grid[])]

write.csv( format.df( peelDf,
                     dec=3,
                     numeric.dollar=FALSE,
                     na.blank= TRUE),
          file= "peel.csv",
          quote= FALSE)

file.copy( "peel.csv", "~/see/data/cimdb/peel_thesis.csv",
          overwrite=TRUE)


## peelData <- brick( aglandComplete, cropSubClasses)

@ %def 

@ 
<<cleanup, eval=TRUE>>=
options( prompt= "> ", continue= "+ ", width= 80)
@ %def 

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "thesis"
%%% End: 

